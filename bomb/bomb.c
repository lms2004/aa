/***************************************************************************
 * 恶博士的阴险炸弹，版本 1.1
 * 版权所有 2011，恶博士公司。保留所有权利。
 *
 * 许可证：
 *
 * 恶博士公司（犯罪者）特此授予你（受害者）明确使用此炸弹（炸弹）的权限。
 * 这是一个有限时间的许可证，期限为受害者的生命期。
 * 犯罪者对受害者造成的任何损害、挫折、精神错乱、眼球突出的症状、腕管综合症、失眠或其他损害不负任何责任。
 * 除非犯罪者想要因此获得荣誉。受害者不得将此炸弹的源代码分发给犯罪者的任何敌人。
 * 任何受害者不得调试、反向工程、运行“strings”命令、反编译、解密或使用任何其他技术获取并拆除炸弹。
 * 在处理此程序时不得穿戴防炸服。
 * 犯罪者不会为其糟糕的幽默感道歉。
 * 在法律禁止此炸弹的地方，此许可证无效。
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "support.h"
#include "phases.h"

/* 
 * 自我提醒：记得删除这个文件，这样我的受害者就不知道发生了什么，
 * 他们都会在一场壮观的邪恶爆炸中爆炸。 -- 恶博士 
 */

FILE *infile;

int main(int argc, char *argv[])
{
    char *input;

    /* 自我提醒：记得将这个炸弹移植到 Windows 并放上一个炫酷的 GUI。 */

    /* 当不带参数运行时，炸弹从标准输入读取输入行。 */
    if (argc == 1) {  
	infile = stdin;
    } 

    /* 当带一个参数 <file> 运行时，炸弹从 <file> 读取直到 EOF，然后切换到标准输入。
     * 因此，当你拆除每个阶段时，可以将拆除字符串添加到 <file> 中，
     * 避免重复输入。 */
    else if (argc == 2) {
	if (!(infile = fopen(argv[1], "r"))) {
	    printf("%s: 错误: 无法打开 %s\n", argv[0], argv[1]);
	    exit(8);
	}
    }

    /* 你不能带超过 1 个命令行参数运行炸弹。 */
    else {
	printf("用法: %s [<input_file>]\n", argv[0]);
	exit(8);
    }

    /* 做各种秘密的事情，使炸弹更难拆除。 */
    initialize_bomb();

    printf("欢迎来到我的邪恶小炸弹。你有 6 个阶段来把自己炸飞。祝你有美好的一天！\n");

    /* 嗯... 六个阶段一定比一个阶段更安全！ */
    input = read_line();             /* 获取输入                   */
    phase_1(input);                  /* 运行阶段                   */
    phase_defused();                 /* 哎呀！他们搞清楚了！
				      * 让我知道他们是怎么做到的。 */
    printf("阶段 1 拆除成功。下一个怎么样？\n");

    /* 第二阶段更难。没人能搞清楚
     * 如何拆除这个... */
    input = read_line();
    phase_2(input);
    phase_defused();
    printf("那是第 2 阶段。继续加油！\n");

    /* 我想这到目前为止太容易了。一些更复杂的代码会
     * 让人困惑。 */
    input = read_line();
    phase_3(input);
    phase_defused();
    printf("完成了一半！\n");

    /* 哦对吗？那么你的数学水平如何？试试这个棘手的问题！ */
    input = read_line();
    phase_4(input);
    phase_defused();
    printf("你解决了这个。试试下一个。\n");
    
    /* 在内存中绕来绕去，炸弹会在我们停下的地方爆炸！ */
    input = read_line();
    phase_5(input);
    phase_defused();
    printf("干得好！继续下一个...\n");

    /* 这个阶段永远不会被使用，因为没有人能通过
     * 前面的阶段。但以防万一，让这个阶段特别难。 */
    input = read_line();
    phase_6(input);
    phase_defused();

    /* 哇，他们搞定了！但是不是有些东西...遗漏了？也许
     * 是他们忽略了什么？哈哈哈哈哈！ */
    
    return 0;
}
